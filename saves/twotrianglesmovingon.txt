// glad is needed since modern openGL is not a library you link against directly... 
// the openGL driver exposes function pointers at runtime so glad works as an EXPOSERRRR

#include <glad/glad.h> 
#include <GLFW/glfw3.h>
#include <stb_image/stb_image.h>

#include <iostream>
#include <cmath>

#include <Shader.h>

// helper input function definitions
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// program settings
const unsigned int WIDTH = 800;
const unsigned int HEIGHT = 600;

// for system output messages
int success;
char infoLog[512];

// Controls
const unsigned int WIREFRAME_KEY = GLFW_KEY_GRAVE_ACCENT;

int main() {
    // glfw window init with some slight error "handling"
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW\n";
        return -1;
    }

    // some configurations... here we are telling it to using glfw to use version 3.3
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // tell GLFW we want to explicitly use the core-profile.

    // creating the window object... holds all the "windowing" data and is passed frquently as an arg for glfw's other functions
    GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "Game", nullptr, nullptr);
    if (!window) {
        std::cerr << "Failed to create GLFW window\n";
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);

    // doing this so that OpenGL knows how we want to display the data coordinates with respect to the window.
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    
    // init for GLAD...
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Failed to initialize GLAD\n";
        return -1;
    }

    // CREATING SHADER PROGRAM WITH OUR SHADER CLASS, weve abstracted this nicely so its super clean.
    Shader firstShader("../shaders/shaderlearningv.glsl", "../shaders/shaderlearningf.glsl");
    Shader secondShader("../shaders/shaderlearningv.glsl", "../shaders/greentest.glsl");

    // vector specification
    float triangle_one[] = {
    //   x      y     z     r     g     b
        -0.9f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f,  // left 
        -0.0f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // right
        -0.45f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // top 
    }; 

    float triangle_two[] = {
    //  x      y     z     r     g     b
        0.0f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f,  // left
        0.9f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // right
        0.45f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // top 
    };

    // triangle rendering...

    // Generate our vertex specification stuff
    unsigned int VertexBufferOne, VertexArrayOne, VertexBufferTwo, VertexArrayTwo;
    glGenVertexArrays(1, &VertexArrayOne);
    glGenVertexArrays(1, &VertexArrayTwo);
    glGenBuffers(1, &VertexBufferOne);
    glGenBuffers(1, &VertexBufferTwo);
    
    // ------------------------ Triangle One ------------------------

    // bind our VAO and VBO
    glBindVertexArray(VertexArrayOne); // tell openGL that we are now using this array
    glBindBuffer(GL_ARRAY_BUFFER, VertexBufferOne);

    // RAINBOWS

    // defining position attribute
    // This line here is super important. It captures the currently bound GL_ARRAY_BUFFER and saves it as a reference, linking the two
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // defining color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));
    glEnableVertexAttribArray(1);

    // insert data into the buffer
    glBufferData(GL_ARRAY_BUFFER, sizeof(triangle_one), triangle_one, GL_STATIC_DRAW);

    // ------------------------ Triangle Two ------------------------

    // BIND & SET VAO ATRRIBUTES
    glBindVertexArray(VertexArrayTwo);
    glBindBuffer(GL_ARRAY_BUFFER, VertexBufferTwo);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // defining color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));
    glEnableVertexAttribArray(1);

    // LOAD DATA INTO SECOND BUFFER
    glBufferData(GL_ARRAY_BUFFER, sizeof(triangle_two), triangle_two, GL_STATIC_DRAW);
    
    glBindVertexArray(0); // unbinds the vertex array entirely.

    // ------------------------ Textures ------------------------

    // texture object creation and settings

    // unsigned int texture; // unsigned int array
    // glGenTextures(GL_TEXTURE_2D, &texture); // pass in the address of the ID.
    // glBindTexture(GL_TEXTURE_2D, texture); // bind similarly to the VAO and VBO objects in context

    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); // as we go down in object size (and so less pizels on the screen) please use the minmap we generate
    // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // no need to use the minmap for increase in scale.

    // // texture loading (pureley loading the data)

    // int width, height, nrChannels;
    // unsigned char *data = stbi_load("../assets/textures/container.jpg", &width, &height, &nrChannels, 0);
    // if(data)
    // {
    //     // we found the file so no errors
    //     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
    //     glGenerateMipmap(GL_TEXTURE_2D); // generates mipmap (texture samples at half size for downscaling purposes) out of currently bound texture.
    // } else 
    // {
    //     // we print to the console that something went wrong
    //     std::cout << "something went wrong with texture load :(" << std::endl;
    // }

    // stbi_image_free(data); // we can tell stbi to let the image data go (good practice), since we have mapped it to our OpenGL context

    // render loop 
    while (!glfwWindowShouldClose(window)) {
        // input handling (at the start of every iteration)
        processInput(window);
    
        // basic rendering commands go here
        glClearColor(0.2f, 0.3f, 0.4f, 1.0f); // background color this is "clearing" any empty space with this color
        glClear(GL_COLOR_BUFFER_BIT);

        // triangles
        // glUseProgram(shaderProgram); << how you do things normally.
        firstShader.use();

        // creating our two triangles using two different vertex array objects...
        glBindVertexArray(VertexArrayOne);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        glBindVertexArray(VertexArrayTwo);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        // check and call events and swap the buffers
        glfwSwapBuffers(window);
        glfwPollEvents(); // generally enables checks for keyboard and mouse inputs
    }

    // release everything (this is technically optional)
    glDeleteVertexArrays(1, &VertexArrayOne);
    glDeleteBuffers(1, &VertexBufferOne);
    glDeleteVertexArrays(1, &VertexArrayTwo);
    glDeleteBuffers(1, &VertexBufferTwo);

    // glDeleteBuffers(1, &EBO);
    //glDeleteProgram(shaderProgram);

    // close window and terminate stuff
    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}

// ------------------------------ Input Function Definitions ---------------------------

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0,0,width,height);
}

void processInput(GLFWwindow *window)
{   
    // example of user input handling.
    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }

    // W makes the window into wireframe mode...
    if(glfwGetKey(window, WIREFRAME_KEY) == GLFW_PRESS)
    {
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    }
    if(glfwGetKey(window, WIREFRAME_KEY) == GLFW_RELEASE)
    {
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    }
}