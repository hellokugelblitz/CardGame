// glad is needed since modern openGL is not a library you link against directly... 
// the openGL driver exposes function pointers at runtime so glad works as an EXPOSERRRR

// Third party stuff
#include <glad/glad.h> 
#include <GLFW/glfw3.h>
#include <stb_image/stb_image.h>

// gl math stuff
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

// c++ standard libs
#include <iostream>
#include <cmath>

#include <Shader.h>

// helper input function definitions
void framebuffer_size_callback(GLFWwindow* window, int width, int height);
void processInput(GLFWwindow *window);

// program settings
const unsigned int WIDTH = 800;
const unsigned int HEIGHT = 600;

// for system output messages
int success;
char infoLog[512];

// Controls
const unsigned int WIREFRAME_KEY = GLFW_KEY_GRAVE_ACCENT;
float owlX = 0.5f;
float owlDirection = 90;

int main() {
    // glfw window init with some slight error "handling"
    if (!glfwInit()) {
        std::cerr << "Failed to initialize GLFW\n";
        return -1;
    }

    // some configurations... here we are telling it to using glfw to use version 3.3
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // tell GLFW we want to explicitly use the core-profile.
    

    // creating the window object... holds all the "windowing" data and is passed frquently as an arg for glfw's other functions
    GLFWwindow* window = glfwCreateWindow(WIDTH, HEIGHT, "Game", nullptr, nullptr);
    if (!window) {
        std::cerr << "Failed to create GLFW window\n";
        glfwTerminate();
        return -1;
    }

    glfwMakeContextCurrent(window);

    // doing this so that OpenGL knows how we want to display the data coordinates with respect to the window.
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    
    // init for GLAD...
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "Failed to initialize GLAD\n";
        return -1;
    }

    // CREATING SHADER PROGRAM WITH OUR SHADER CLASS, weve abstracted this nicely so its super clean.
    Shader firstShader("../shaders/shaderlearningv.glsl", "../shaders/shaderlearningf.glsl");
    Shader secondShader("../shaders/shaderlearningv.glsl", "../shaders/greentest.glsl");

    // vector specification
    float sky_verticies[] = {
    //  x     y     z      r     g     b     Texture Coordinates
        1.0f, 1.0f, 0.0f,  0.0f, 1.0f, 0.0f, 1.0f, 1.0f,  // top - right
        1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,  // bottom - right
       -1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,  // bottom - left 
       -1.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f, 1.0f,  // top - left 
    }; 

    float owl_verticies[] = {
    //  x     y     z      r     g     b     Texture Coordinates
        0.25f, 0.25f, 0.0f,  0.0f, 1.0f, 0.0f, 1.0f, 1.0f,  // top - right
        0.25f, -0.25f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,  // bottom - right
       -0.25f, -0.25f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,  // bottom - left 
       -0.25f, 0.25f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f, 1.0f,  // top - left 
    }; 

    // valid ordering: 0, 3, 1 & 3, 2, 1  (respecting counter clockwise winding)
    unsigned int index_buffer_data[] = {
        0,3,1,
        3,2,1
    };

    // Generate our vertex specification stuff
    unsigned int VertexBufferObject, VertexArrayObject, ElementBufferObject;
    unsigned int owlVBO, owlVAO, owlEBO;
    glGenVertexArrays(1, &VertexArrayObject);
    glGenBuffers(1, &VertexBufferObject);
    glGenBuffers(1, &ElementBufferObject);

    glGenVertexArrays(1, &owlVAO);
    glGenBuffers(1, &owlVBO);
    glGenBuffers(1, &owlEBO);
    
    // ------------------------ QUAD ------------------------

    // bind our VAO and VBO
    glBindVertexArray(VertexArrayObject); // tell openGL that we are now using this array
    glBindBuffer(GL_ARRAY_BUFFER, VertexBufferObject);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ElementBufferObject);

    // RAINBOWS

    // defining position attribute
    // This line here is super important. It captures the currently bound GL_ARRAY_BUFFER and saves it as a reference, linking the two
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // defining color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3* sizeof(float)));
    glEnableVertexAttribArray(1);

    // defining texture attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6* sizeof(float)));
    glEnableVertexAttribArray(2);

    // insert data into the buffer
    glBufferData(GL_ARRAY_BUFFER, sizeof(sky_verticies), sky_verticies, GL_STATIC_DRAW);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(index_buffer_data), index_buffer_data, GL_STATIC_DRAW);

    // ---------------------- Owl Stuff -----------------------

    glBindVertexArray(owlVAO);
    glBindBuffer(GL_ARRAY_BUFFER, owlVBO);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, owlEBO);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    // defining color attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3* sizeof(float)));
    glEnableVertexAttribArray(1);

    // defining texture attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6* sizeof(float)));
    glEnableVertexAttribArray(2);

    glBufferData(GL_ARRAY_BUFFER, sizeof(owl_verticies), owl_verticies, GL_STATIC_DRAW);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(index_buffer_data), index_buffer_data, GL_STATIC_DRAW);

    glBindVertexArray(0); // unbinds the vertex array entirely.


    // ------------------------ Textures ------------------------

    // texture object creation and settings

    unsigned int textureOne, textureTwo; // unsigned int array
    glGenTextures(1, &textureOne); // pass in the address of the ID.
    glGenTextures(1, &textureTwo);
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, textureOne); // bind similarly to the VAO and VBO objects in context

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); // as we go down in object size (and so less pizels on the screen) please use the minmap we generate
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // no need to use the minmap for increase in scale.

    // texture loading (pureley loading the data)

    stbi_set_flip_vertically_on_load(1); // since images are generally written from top left, and OpenGL renders from bottom left.

    // Background
    int width, height, nrChannels;
    unsigned char *data = stbi_load("../assets/textures/sky.jpg", &width, &height, &nrChannels, 0);

    // Owl
    int owlWidth, owlHeight, owlNR;
    unsigned char *owl = stbi_load("../assets/textures/owl.png", &owlWidth, &owlHeight, &owlNR, 0);

    // Daniel Radcliffe

    if(data)
    {
        // we found the file so no errors
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
        glGenerateMipmap(GL_TEXTURE_2D); // generates mipmap (texture samples at half size for downscaling purposes) out of currently bound texture.
    }
    
    glActiveTexture(GL_TEXTURE1);
    glBindTexture(GL_TEXTURE_2D, textureTwo); // bind second texture in the same way we bound the first...

    if(owl)
    {
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, owlWidth, owlHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, owl);
        glGenerateMipmap(GL_TEXTURE_2D);
    }

    stbi_image_free(data); // we can tell stbi to let the image data go (good practice), since we have mapped it to our OpenGL context

    // render loop 
    while (!glfwWindowShouldClose(window)) {
        // input handling (at the start of every iteration)
        processInput(window);
    
        // basic rendering commands go here
        glClearColor(0.2f, 0.3f, 0.4f, 1.0f); // background color this is "clearing" any empty space with this color
        glClear(GL_COLOR_BUFFER_BIT);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        // triangles
        // glUseProgram(shaderProgram); << how you do things normally.
        firstShader.use();
        glUniform1i(glGetUniformLocation(firstShader.ID, "objectTexture"), 0);

        // order for matrix transforms is: 
        
        
        // // we give it a matrix, a radian amount for rotation and an exis in the form of a vector3 (unit)
        // trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));
        // // rotating by time
        // trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0, 1.0, 0.0));
        // // scale is self explanitory
        // trans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5));

        // getting the location of our uniform in the vertex shader, and setting it to our newly transform matrix above.

        unsigned int transformLoc = glGetUniformLocation(firstShader.ID, "transform");

        glm::mat4 skytrans = glm::mat4(1.0f);
        glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(skytrans));

        // creating our two triangles using two different vertex array objects...
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, textureOne);
    
        glBindVertexArray(VertexArrayObject);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

        glm::mat4 owltrans = glm::mat4(1.0f);
        owltrans = glm::translate(owltrans, glm::vec3(owlX,0.0f,0.0f));
        // owltrans = glm::rotate(owltrans, glm::radians(owlDirection), glm::vec3(0.0, 1.0, 0.0));
        glUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(owltrans));

        glBindTexture(GL_TEXTURE_2D, textureTwo);

        glBindVertexArray(owlVAO);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);

        // check and call events and swap the buffers
        glfwSwapBuffers(window);
        glfwPollEvents(); // generally enables checks for keyboard and mouse inputs
    }

    // release everything (this is technically optional)
    glDeleteVertexArrays(1, &VertexArrayObject);
    glDeleteBuffers(1, &VertexBufferObject);

    // glDeleteBuffers(1, &EBO);
    //glDeleteProgram(shaderProgram);

    // close window and terminate stuff
    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}

// ------------------------------ Input Function Definitions ---------------------------

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
    glViewport(0,0,width,height);
}

void processInput(GLFWwindow *window)
{   
    // example of user input handling.
    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
    {
        glfwSetWindowShouldClose(window, true);
    }

    // W makes the window into wireframe mode...
    if(glfwGetKey(window, WIREFRAME_KEY) == GLFW_PRESS)
    {
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    }
    if(glfwGetKey(window, WIREFRAME_KEY) == GLFW_RELEASE)
    {
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    }

    // Arrow keys input
    if(glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
    {
        owlX+=0.01f;
    }
    if(glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
    {
        owlX-=0.01f;
    }
}